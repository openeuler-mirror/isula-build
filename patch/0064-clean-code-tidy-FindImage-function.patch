From 9b1191dafa500bc55b37912898e3ebb8e9d6ec24 Mon Sep 17 00:00:00 2001
From: xingweizheng <xingweizheng@huawei.com>
Date: Sat, 28 Aug 2021 23:27:49 +0800
Subject: [PATCH 15/20] clean code: tidy FindImage function

---
 daemon/images.go                   |  2 +-
 daemon/images_test.go              |  2 +-
 daemon/push_test.go                |  2 +-
 daemon/remove.go                   |  2 +-
 daemon/save.go                     |  2 +-
 daemon/save_test.go                |  2 +-
 exporter/docker/archive/archive.go |  4 +-
 image/image.go                     | 67 ++++++------------------------
 image/image_test.go                |  2 +-
 9 files changed, 21 insertions(+), 64 deletions(-)

diff --git a/daemon/images.go b/daemon/images.go
index e61817cc..baeb375c 100644
--- a/daemon/images.go
+++ b/daemon/images.go
@@ -70,7 +70,7 @@ func listOneImage(opts listOptions) (*pb.ListResponse, error) {
 	_, image, err := image.FindImage(opts.localStore, opts.imageName)
 	if err != nil {
 		opts.logEntry.Error(err)
-		return nil, errors.Wrapf(err, "find local image %v error", opts.imageName)
+		return nil, errors.Wrapf(err, "find local image %q failed", opts.imageName)
 	}
 
 	result := make([]*pb.ListResponse_ImageInfo, 0, len(image.Names))
diff --git a/daemon/images_test.go b/daemon/images_test.go
index a970ce0b..efbf6f14 100644
--- a/daemon/images_test.go
+++ b/daemon/images_test.go
@@ -96,7 +96,7 @@ func TestList(t *testing.T) {
 				ImageName: "coffee:costa",
 			},
 			wantErr:   true,
-			errString: "failed to parse image",
+			errString: "not found in local store",
 		},
 		{
 			name: "abnormal case no repository",
diff --git a/daemon/push_test.go b/daemon/push_test.go
index f4a9e2b1..7358d0cd 100644
--- a/daemon/push_test.go
+++ b/daemon/push_test.go
@@ -69,7 +69,7 @@ func TestPush(t *testing.T) {
 				Format:    "docker",
 			},
 			wantErr:   true,
-			errString: "failed to parse image",
+			errString: "not found in local store",
 		},
 		{
 			name: "manifestNotExist",
diff --git a/daemon/remove.go b/daemon/remove.go
index 89e68cfc..d4e0bbd9 100644
--- a/daemon/remove.go
+++ b/daemon/remove.go
@@ -49,7 +49,7 @@ func (b *Backend) Remove(req *pb.RemoveRequest, stream pb.Control_RemoveServer)
 	}
 
 	for _, imageID := range rmImageIDs {
-		_, img, err := image.FindImageLocally(s, imageID)
+		_, img, err := image.FindImage(s, imageID)
 		if err != nil {
 			rmFailed = true
 			errMsg := fmt.Sprintf("Find local image %q failed: %v", imageID, err)
diff --git a/daemon/save.go b/daemon/save.go
index 7ad12851..1a2d3fed 100644
--- a/daemon/save.go
+++ b/daemon/save.go
@@ -186,7 +186,7 @@ func filterImageName(opts *saveOptions) error {
 		}
 		visitedImage[imageName] = true
 
-		_, img, err := image.FindImageLocally(opts.localStore, imageName)
+		_, img, err := image.FindImage(opts.localStore, imageName)
 		if err != nil {
 			return errors.Wrapf(err, "filter image name failed when finding image name %q", imageName)
 		}
diff --git a/daemon/save_test.go b/daemon/save_test.go
index a59086a8..c1b37342 100644
--- a/daemon/save_test.go
+++ b/daemon/save_test.go
@@ -129,7 +129,7 @@ func TestSave(t *testing.T) {
 				Format: "docker",
 			},
 			wantErr:   true,
-			errString: "failed to parse image",
+			errString: "not found in local store",
 		},
 		{
 			name: "abnormal case wrong image format",
diff --git a/exporter/docker/archive/archive.go b/exporter/docker/archive/archive.go
index cc6b8721..36a28811 100644
--- a/exporter/docker/archive/archive.go
+++ b/exporter/docker/archive/archive.go
@@ -60,7 +60,7 @@ func (d *dockerArchiveExporter) Init(opts exporter.ExportOptions, src, destSpec
 	// destSpec could be "file:name:tag" or "file:name" or just "file" with transport "docker-archive", such as docker-archive:output.tar:name:tag
 	// When more than two parts, build must be called
 	if parts := strings.Split(destSpec, ":"); len(parts) > partsNum {
-		srcReference, _, err = image.FindImageLocally(localStore, src)
+		srcReference, _, err = image.FindImage(localStore, src)
 		if err != nil {
 			return errors.Wrapf(err, "find src image: %q failed with transport %q", src, d.Name())
 		}
@@ -89,7 +89,7 @@ func (d *dockerArchiveExporter) Init(opts exporter.ExportOptions, src, destSpec
 		DockerArchiveExporter.InitArchiveWriter(opts.ExportID, archWriter)
 	}
 
-	srcReference, _, err = image.FindImageLocally(localStore, src)
+	srcReference, _, err = image.FindImage(localStore, src)
 	if err != nil {
 		return errors.Wrapf(err, "find src image: %q failed with transport %q", src, d.Name())
 	}
diff --git a/image/image.go b/image/image.go
index 5ae7245e..4a1ca881 100644
--- a/image/image.go
+++ b/image/image.go
@@ -468,71 +468,29 @@ func ResolveImageName(s string, resolveArg func(string) string) (string, error)
 	return newStr, nil
 }
 
-// FindImage get the image from storage by image describe
+// FindImage get the image from local storage by image describe
 func FindImage(store *store.Store, image string) (types.ImageReference, *storage.Image, error) {
-	names, _, err := ResolveName(image, nil, store)
-	if err != nil {
-		return nil, nil, errors.Wrapf(err, "error parsing name %q", image)
-	}
-
-	ref, img, err := ParseImagesToReference(store, names)
-	if err != nil {
-		return nil, nil, errors.Wrapf(err, "locating image %q failed", image)
-	}
-	return ref, img, nil
-}
-
-// FindImageLocally get the image from local storage by image describe
-func FindImageLocally(store *store.Store, image string) (types.ImageReference, *storage.Image, error) {
 	// 1. check name valid
-	if image == "" {
-		return nil, nil, errors.Errorf("image name %q cannot be empty string", image)
+	if _, err := reference.Parse(image); err != nil {
+		return nil, nil, errors.Wrapf(err, "parse image %q failed", image)
 	}
 
 	// 2. try to find image with name or id in local store
 	localName := tryResolveNameInStore(image, store)
 	if localName == "" {
-		return nil, nil, errors.Errorf("no image %q in local store", image)
+		return nil, nil, errors.Errorf("image %q not found in local store", image)
 	}
 
-	// 3. parse to image reference
-	ref, img, err := ParseImagesToReference(store, []string{localName})
+	// 3. get image reference and storage.Image
+	ref, err := is.Transport.ParseStoreReference(store, localName)
 	if err != nil {
-		return nil, nil, errors.Wrapf(err, "locating image %q locally failed", image)
-	}
-	return ref, img, nil
-}
-
-// ParseImagesToReference get the image reference in store
-func ParseImagesToReference(store *store.Store, names []string) (types.ImageReference, *storage.Image, error) {
-	var (
-		ref types.ImageReference
-		img *storage.Image
-		err error
-	)
-	for _, name := range names {
-		ref, err = is.Transport.ParseStoreReference(store, name)
-		if err != nil {
-			logrus.Debugf("Error parsing reference to image %q: %v", name, err)
-			continue
-		}
-
-		var gErr error
-		img, gErr = is.Transport.GetStoreImage(store, ref)
-		// When name is the format of name[:rag] with out registry domain, err is storage.ErrImageUnknown
-		if gErr != nil {
-			img2, err2 := store.Image(name)
-			if err2 != nil {
-				logrus.Debugf("Error locating image %q: %v", name, err2)
-				continue
-			}
-			img = img2
-		}
-		break
+		return nil, nil, errors.Wrapf(err, "error parsing reference to image %q", localName)
 	}
-	if ref == nil || img == nil || err != nil {
-		return nil, nil, errors.Errorf("failed to parse image %v in local store", names)
+	img, err := is.Transport.GetStoreImage(store, ref)
+	if err != nil {
+		return nil, nil, errors.Wrapf(err, "failed to parse image %q in local store", localName)
 	}
+	
 	return ref, img, nil
 }
 
@@ -572,14 +530,13 @@ func ResolveName(name string, sc *types.SystemContext, store *store.Store) ([]st
 }
 
 func tryResolveNameInStore(name string, store *store.Store) string {
-	defaultTag := "latest"
-
 	logrus.Infof("Try to find image: %s in local storage", name)
 	img, err := store.Image(name)
 	if err == nil {
 		return img.ID
 	}
 
+	defaultTag := "latest"
 	logrus.Infof("Try to find image: %s:%s in local storage", name, defaultTag)
 	img, err = store.Image(fmt.Sprintf("%s:%s", name, defaultTag))
 	if err != nil {
diff --git a/image/image_test.go b/image/image_test.go
index c698b4d8..43d936f5 100644
--- a/image/image_test.go
+++ b/image/image_test.go
@@ -51,7 +51,7 @@ func TestFindImageWhenImageNameIsEmpty(t *testing.T) {
 
 	src := ""
 	srcReference, _, err := FindImage(&localStore, src)
-	assert.ErrorContains(t, err, "locating image")
+	assert.ErrorContains(t, err, "repository name must have at least one component")
 	assert.Assert(t, cmp.Nil(srcReference))
 }
 
-- 
2.31.1

