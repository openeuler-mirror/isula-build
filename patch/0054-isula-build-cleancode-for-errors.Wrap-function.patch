From 80422e04f262f925458e7cee6986edb0903cef71 Mon Sep 17 00:00:00 2001
From: DCCooper <1866858@gmail.com>
Date: Tue, 15 Jun 2021 20:01:25 +0800
Subject: [PATCH] isula-build:cleancode for errors.Wrap function

Signed-off-by: DCCooper <1866858@gmail.com>
---
 cmd/cli/grpc_client.go | 2 +-
 daemon/load.go         | 2 +-
 exporter/common.go     | 2 +-
 image/image.go         | 6 +++---
 4 files changed, 6 insertions(+), 6 deletions(-)

diff --git a/cmd/cli/grpc_client.go b/cmd/cli/grpc_client.go
index 5f10fb0..cab5950 100644
--- a/cmd/cli/grpc_client.go
+++ b/cmd/cli/grpc_client.go
@@ -82,7 +82,7 @@ func NewClient(ctx context.Context) (*GrpcClient, error) {
 	defer cancel()
 	connected, err := cli.HealthCheck(healthCtx)
 	if !connected || err != nil {
-		return nil, errors.Wrapf(err, "Cannot connect to the isula-builder at %s. Is the isula-builder running?\nError", constant.DefaultGRPCAddress)
+		return nil, errors.Errorf( "Cannot connect to the isula-builder at %s. Is the isula-builder running?\nError: %v", constant.DefaultGRPCAddress, err)
 	}
 
 	return cli, nil
diff --git a/daemon/load.go b/daemon/load.go
index f2d818f..2fb8e27 100644
--- a/daemon/load.go
+++ b/daemon/load.go
@@ -154,7 +154,7 @@ func getDockerRepoTagFromImageTar(systemContext *types.SystemContext, path strin
 
 	topLevelImageManifest, err := tarfileSource.LoadTarManifest()
 	if err != nil || len(topLevelImageManifest) == 0 {
-		return nil, errors.Wrapf(err, "failed to get the top level image manifest")
+		return nil, errors.Errorf("failed to get the top level image manifest: %v", err)
 	}
 
 	var allRepoTags [][]string
diff --git a/exporter/common.go b/exporter/common.go
index bded6ec..cd976d2 100644
--- a/exporter/common.go
+++ b/exporter/common.go
@@ -132,7 +132,7 @@ func export(e Exporter, exOpts ExportOptions) (reference.Canonical, digest.Diges
 
 	destRef, srcRef := e.GetDestRef(exOpts.ExportID), e.GetSrcRef(exOpts.ExportID)
 	if destRef == nil || srcRef == nil {
-		return nil, "", errors.Wrapf(err, "get dest or src reference by export ID %v failed", exOpts.ExportID)
+		return nil, "", errors.Errorf("get dest or src reference by export ID %v failed %v", exOpts.ExportID, err)
 	}
 
 	if manifestBytes, err = cp.Image(exOpts.Ctx, policyContext, destRef, srcRef, cpOpts); err != nil {
diff --git a/image/image.go b/image/image.go
index 91ab720..e06d253 100644
--- a/image/image.go
+++ b/image/image.go
@@ -314,7 +314,7 @@ func createImageV2Image(ctx context.Context, fromImage types.Image, targetMIMETy
 			ManifestMIMEType: targetMIMEType,
 		})
 		if err2 != nil {
-			return nil, errors.Wrapf(err, "failed to convert image %q", imageName)
+			return nil, errors.Wrapf(err2, "failed to convert image %q", imageName)
 		}
 		fromImage = updatedImg
 	}
@@ -533,7 +533,7 @@ func ParseImagesToReference(store *store.Store, names []string) (types.ImageRefe
 			// For support export archive file, we need provide reference.Named field when names is the format of name[:tag] not the image ID
 			pRef, pErr := reference.Parse(name)
 			if pErr != nil {
-				return nil, nil, errors.Wrapf(err, "error parse name %q", name)
+				return nil, nil, errors.Wrapf(pErr, "error parse name %q", name)
 			}
 			namedRef, isNamed := pRef.(reference.Named)
 			if !isNamed {
@@ -543,7 +543,7 @@ func ParseImagesToReference(store *store.Store, names []string) (types.ImageRefe
 			var nErr error
 			ref, nErr = is.Transport.NewStoreReference(store, namedRef, img2.ID)
 			if nErr != nil {
-				return nil, nil, errors.Wrap(err, "error get reference from store")
+				return nil, nil, errors.Wrap(nErr, "error get reference from store")
 			}
 		}
 		break
-- 
1.8.3.1

